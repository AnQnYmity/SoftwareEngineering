#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include "../include/storage/TransactionRepository.h"
#include "../include/storage/IStorage.h"
#include <memory>
#include <thread>
#include <chrono>

// Mock Storage class for testing
class MockStorage : public IStorage {
public:
    MOCK_METHOD(void, save, (const std::string& key, const std::string& data), (override));
    MOCK_METHOD(std::string, load, (const std::string& key), (override));
    MOCK_METHOD(std::string, backup, (), (override));
    MOCK_METHOD(bool, exists, (const std::string& key), (override));
    MOCK_METHOD(void, remove, (const std::string& key), (override));
};

// Test fixture for TransactionRepository
class TransactionRepositoryTest : public ::testing::Test {
protected:
    std::shared_ptr<MockStorage> mockStorage;
    std::shared_ptr<TransactionRepository> repository;

    void SetUp() override {
        mockStorage = std::make_shared<MockStorage>();
        // Mock storage to return empty data initially
        EXPECT_CALL(*mockStorage, load(testing::_))
            .WillRepeatedly(testing::Return("[]"));
        EXPECT_CALL(*mockStorage, save(testing::_, testing::_))
            .WillRepeatedly(testing::Return());
        
        repository = std::make_shared<TransactionRepository>(mockStorage);
    }

    void TearDown() override {
        repository.reset();
        mockStorage.reset();
    }
};

// Test Case 1: Add transaction with auto-generated ID
TEST_F(TransactionRepositoryTest, AddTransactionWithAutoGeneratedId) {
    Transaction tx;
    tx.amount = 100.0;
    tx.type = TransactionType::EXPENSE;
    tx.categoryId = "food";
    tx.note = "Lunch";
    tx.date = time(nullptr);

    Transaction result = repository->add(tx);

    EXPECT_FALSE(result.id.empty());
    EXPECT_EQ(result.amount, 100.0);
    EXPECT_EQ(result.type, TransactionType::EXPENSE);
    EXPECT_EQ(result.categoryId, "food");
    EXPECT_FALSE(result.isDeleted);
}

// Test Case 2: Add transaction with provided ID
TEST_F(TransactionRepositoryTest, AddTransactionWithProvidedId) {
    Transaction tx;
    tx.id = "custom_id_001";
    tx.amount = 200.0;
    tx.type = TransactionType::INCOME;
    tx.categoryId = "salary";
    tx.note = "Monthly salary";
    tx.date = time(nullptr);

    Transaction result = repository->add(tx);

    EXPECT_EQ(result.id, "custom_id_001");
    EXPECT_EQ(result.amount, 200.0);
    EXPECT_EQ(result.type, TransactionType::INCOME);
}

// Test Case 3: Add transaction with zero amount (boundary)
TEST_F(TransactionRepositoryTest, AddTransactionWithZeroAmount) {
    Transaction tx;
    tx.amount = 0.0;
    tx.type = TransactionType::EXPENSE;
    tx.categoryId = "misc";
    tx.note = "Zero amount";
    tx.date = time(nullptr);

    Transaction result = repository->add(tx);

    EXPECT_EQ(result.amount, 0.0);
    EXPECT_FALSE(result.id.empty());
}

// Test Case 4: Add transaction with negative amount (boundary)
TEST_F(TransactionRepositoryTest, AddTransactionWithNegativeAmount) {
    Transaction tx;
    tx.amount = -50.0;
    tx.type = TransactionType::EXPENSE;
    tx.categoryId = "misc";
    tx.note = "Negative amount";
    tx.date = time(nullptr);

    Transaction result = repository->add(tx);

    EXPECT_EQ(result.amount, -50.0);
}

// Test Case 5: Add transaction with very large amount (boundary)
TEST_F(TransactionRepositoryTest, AddTransactionWithLargeAmount) {
    Transaction tx;
    tx.amount = 999999999.99;
    tx.type = TransactionType::INCOME;
    tx.categoryId = "investment";
    tx.note = "Large amount";
    tx.date = time(nullptr);

    Transaction result = repository->add(tx);

    EXPECT_EQ(result.amount, 999999999.99);
}

// Test Case 6: Update existing transaction
TEST_F(TransactionRepositoryTest, UpdateExistingTransaction) {
    // Add a transaction first
    Transaction tx;
    tx.amount = 100.0;
    tx.type = TransactionType::EXPENSE;
    tx.categoryId = "food";
    tx.note = "Original note";
    tx.date = time(nullptr);

    Transaction added = repository->add(tx);

    // Small delay to ensure different timestamps
    std::this_thread::sleep_for(std::chrono::milliseconds(100));

    // Update it
    added.amount = 150.0;
    added.note = "Updated note";

    Transaction updated = repository->update(added);

    EXPECT_EQ(updated.amount, 150.0);
    EXPECT_EQ(updated.note, "Updated note");
    EXPECT_GE(updated.updatedAt, updated.createdAt);
}

// Test Case 7: Update non-existent transaction (error handling)
TEST_F(TransactionRepositoryTest, UpdateNonExistentTransaction) {
    Transaction tx;
    tx.id = "non_existent_id";
    tx.amount = 100.0;

    EXPECT_THROW({
        repository->update(tx);
    }, std::runtime_error);
}

// Test Case 8: Remove transaction (soft delete)
TEST_F(TransactionRepositoryTest, RemoveTransaction) {
    // Add a transaction
    Transaction tx;
    tx.amount = 100.0;
    tx.type = TransactionType::EXPENSE;
    tx.categoryId = "food";
    tx.note = "To be deleted";
    tx.date = time(nullptr);

    Transaction added = repository->add(tx);

    // Remove it
    repository->remove(added.id);

    // Try to get it (should throw)
    EXPECT_THROW({
        repository->getById(added.id);
    }, std::runtime_error);
}

// Test Case 9: Get transaction by ID
TEST_F(TransactionRepositoryTest, GetTransactionById) {
    Transaction tx;
    tx.amount = 100.0;
    tx.type = TransactionType::EXPENSE;
    tx.categoryId = "food";
    tx.note = "Test note";
    tx.date = time(nullptr);

    Transaction added = repository->add(tx);
    Transaction retrieved = repository->getById(added.id);

    EXPECT_EQ(retrieved.id, added.id);
    EXPECT_EQ(retrieved.amount, 100.0);
    EXPECT_EQ(retrieved.note, "Test note");
}

// Test Case 10: Get non-existent transaction by ID
TEST_F(TransactionRepositoryTest, GetNonExistentTransactionById) {
    EXPECT_THROW({
        repository->getById("non_existent_id");
    }, std::runtime_error);
}

// Test Case 11: Find transactions by category
TEST_F(TransactionRepositoryTest, FindTransactionsByCategory) {
    // Add multiple transactions
    Transaction tx1;
    tx1.amount = 50.0;
    tx1.type = TransactionType::EXPENSE;
    tx1.categoryId = "food";
    tx1.note = "Breakfast";
    tx1.date = time(nullptr);
    repository->add(tx1);

    Transaction tx2;
    tx2.amount = 100.0;
    tx2.type = TransactionType::EXPENSE;
    tx2.categoryId = "food";
    tx2.note = "Lunch";
    tx2.date = time(nullptr);
    repository->add(tx2);

    Transaction tx3;
    tx3.amount = 200.0;
    tx3.type = TransactionType::EXPENSE;
    tx3.categoryId = "transport";
    tx3.note = "Bus";
    tx3.date = time(nullptr);
    repository->add(tx3);

    // Find by category
    TransactionFilter filter;
    filter.categoryId = "food";

    std::vector<Transaction> result = repository->find(filter);

    EXPECT_EQ(result.size(), 2);
}

// Test Case 12: Find transactions by type
TEST_F(TransactionRepositoryTest, FindTransactionsByType) {
    Transaction tx1;
    tx1.amount = 50.0;
    tx1.type = TransactionType::EXPENSE;
    tx1.categoryId = "food";
    tx1.date = time(nullptr);
    repository->add(tx1);

    Transaction tx2;
    tx2.amount = 1000.0;
    tx2.type = TransactionType::INCOME;
    tx2.categoryId = "salary";
    tx2.date = time(nullptr);
    repository->add(tx2);

    TransactionFilter filter;
    TransactionType incomeType = TransactionType::INCOME;
    filter.type = &incomeType;

    std::vector<Transaction> result = repository->find(filter);

    EXPECT_EQ(result.size(), 1);
    EXPECT_EQ(result[0].type, TransactionType::INCOME);
}

// Test Case 13: Find transactions by date range
TEST_F(TransactionRepositoryTest, FindTransactionsByDateRange) {
    time_t now = time(nullptr);
    time_t yesterday = now - 86400;
    time_t tomorrow = now + 86400;

    Transaction tx1;
    tx1.amount = 50.0;
    tx1.type = TransactionType::EXPENSE;
    tx1.categoryId = "food";
    tx1.date = yesterday;
    repository->add(tx1);

    Transaction tx2;
    tx2.amount = 100.0;
    tx2.type = TransactionType::EXPENSE;
    tx2.categoryId = "food";
    tx2.date = now;
    repository->add(tx2);

    Transaction tx3;
    tx3.amount = 150.0;
    tx3.type = TransactionType::EXPENSE;
    tx3.categoryId = "food";
    tx3.date = tomorrow;
    repository->add(tx3);

    TransactionFilter filter;
    filter.dateFrom = yesterday;
    filter.dateTo = now;

    std::vector<Transaction> result = repository->find(filter);

    EXPECT_EQ(result.size(), 2);
}

// Test Case 14: Find transactions by keyword
TEST_F(TransactionRepositoryTest, FindTransactionsByKeyword) {
    Transaction tx1;
    tx1.amount = 50.0;
    tx1.type = TransactionType::EXPENSE;
    tx1.categoryId = "food";
    tx1.note = "Coffee at Starbucks";
    tx1.date = time(nullptr);
    repository->add(tx1);

    Transaction tx2;
    tx2.amount = 100.0;
    tx2.type = TransactionType::EXPENSE;
    tx2.categoryId = "food";
    tx2.note = "Lunch at McDonald's";
    tx2.date = time(nullptr);
    repository->add(tx2);

    TransactionFilter filter;
    filter.keyword = "Starbucks";

    std::vector<Transaction> result = repository->find(filter);

    EXPECT_EQ(result.size(), 1);
    EXPECT_TRUE(result[0].note.find("Starbucks") != std::string::npos);
}

// Test Case 15: Find with empty filter (get all)
TEST_F(TransactionRepositoryTest, FindWithEmptyFilter) {
    Transaction tx1;
    tx1.amount = 50.0;
    tx1.type = TransactionType::EXPENSE;
    tx1.categoryId = "food";
    tx1.date = time(nullptr);
    repository->add(tx1);

    Transaction tx2;
    tx2.amount = 100.0;
    tx2.type = TransactionType::INCOME;
    tx2.categoryId = "salary";
    tx2.date = time(nullptr);
    repository->add(tx2);

    TransactionFilter filter;
    std::vector<Transaction> result = repository->find(filter);

    EXPECT_EQ(result.size(), 2);
}

// Test Case 16: Empty note handling
TEST_F(TransactionRepositoryTest, AddTransactionWithEmptyNote) {
    Transaction tx;
    tx.amount = 100.0;
    tx.type = TransactionType::EXPENSE;
    tx.categoryId = "food";
    tx.note = "";
    tx.date = time(nullptr);

    Transaction result = repository->add(tx);

    EXPECT_EQ(result.note, "");
}
